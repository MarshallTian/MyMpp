/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef FileObjects_TYPES_H
#define FileObjects_TYPES_H

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>



namespace MyMpp {

struct THdfsFileFormat {
  enum type {
    TEXT = 0
  };
};

extern const std::map<int, const char*> _THdfsFileFormat_VALUES_TO_NAMES;

typedef struct _THdfsFileBlock__isset {
  _THdfsFileBlock__isset() : disk_ids(false) {}
  bool disk_ids;
} _THdfsFileBlock__isset;

class THdfsFileBlock {
 public:

  static const char* ascii_fingerprint; // = "C8196C2B7EBDDD72F1AECAB537F8D27A";
  static const uint8_t binary_fingerprint[16]; // = {0xC8,0x19,0x6C,0x2B,0x7E,0xBD,0xDD,0x72,0xF1,0xAE,0xCA,0xB5,0x37,0xF8,0xD2,0x7A};

  THdfsFileBlock() : offset(0), length(0) {
  }

  virtual ~THdfsFileBlock() throw() {}

  int64_t offset;
  int64_t length;
  std::vector<int32_t>  replica_host_idxs;
  std::vector<int32_t>  disk_ids;

  _THdfsFileBlock__isset __isset;

  void __set_offset(const int64_t val) {
    offset = val;
  }

  void __set_length(const int64_t val) {
    length = val;
  }

  void __set_replica_host_idxs(const std::vector<int32_t> & val) {
    replica_host_idxs = val;
  }

  void __set_disk_ids(const std::vector<int32_t> & val) {
    disk_ids = val;
    __isset.disk_ids = true;
  }

  bool operator == (const THdfsFileBlock & rhs) const
  {
    if (!(offset == rhs.offset))
      return false;
    if (!(length == rhs.length))
      return false;
    if (!(replica_host_idxs == rhs.replica_host_idxs))
      return false;
    if (__isset.disk_ids != rhs.__isset.disk_ids)
      return false;
    else if (__isset.disk_ids && !(disk_ids == rhs.disk_ids))
      return false;
    return true;
  }
  bool operator != (const THdfsFileBlock &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const THdfsFileBlock & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(THdfsFileBlock &a, THdfsFileBlock &b);


class THdfsFileDesc {
 public:

  static const char* ascii_fingerprint; // = "A6B3ED0619BEC3BB5A3CB49C8D7B6719";
  static const uint8_t binary_fingerprint[16]; // = {0xA6,0xB3,0xED,0x06,0x19,0xBE,0xC3,0xBB,0x5A,0x3C,0xB4,0x9C,0x8D,0x7B,0x67,0x19};

  THdfsFileDesc() : file_name(), length(0), last_modification_time(0) {
  }

  virtual ~THdfsFileDesc() throw() {}

  std::string file_name;
  int64_t length;
  int64_t last_modification_time;
  std::vector<THdfsFileBlock>  file_blocks;

  void __set_file_name(const std::string& val) {
    file_name = val;
  }

  void __set_length(const int64_t val) {
    length = val;
  }

  void __set_last_modification_time(const int64_t val) {
    last_modification_time = val;
  }

  void __set_file_blocks(const std::vector<THdfsFileBlock> & val) {
    file_blocks = val;
  }

  bool operator == (const THdfsFileDesc & rhs) const
  {
    if (!(file_name == rhs.file_name))
      return false;
    if (!(length == rhs.length))
      return false;
    if (!(last_modification_time == rhs.last_modification_time))
      return false;
    if (!(file_blocks == rhs.file_blocks))
      return false;
    return true;
  }
  bool operator != (const THdfsFileDesc &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const THdfsFileDesc & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(THdfsFileDesc &a, THdfsFileDesc &b);

} // namespace

#endif
